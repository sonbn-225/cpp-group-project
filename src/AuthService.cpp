#include "AuthService.h"
#include "Utils.h"
#include "Constants.h"
#include <iostream>
#include <algorithm>

AuthService::AuthService(DataStorage& ds) : storage(ds), currentUser(nullptr) {}

bool AuthService::registerUser(const std::string& username, const std::string& password,
                               const std::string& fullName, const std::string& email,
                               const std::string& phone, UserRole role,
                               bool autoGeneratedPassword, UserAccount* createdByAdmin) {
    if (storage.findUser(username) != nullptr) {
        std::cerr << "Ten dang nhap '" << username << "' da ton tai." << std::endl;
        return false;
    }
    if (password.length() < MIN_PASSWORD_LENGTH && !autoGeneratedPassword) {
         std::cerr << "Mat khau phai co it nhat " << MIN_PASSWORD_LENGTH << " ky tu." << std::endl;
         return false;
    }

    long long newWalletId = Utils::generateUniqueId();
    UserAccount newUser(username, password, fullName, email, role, phone, newWalletId, autoGeneratedPassword);

    // Create a wallet for the new user
    Wallet newWallet(newWalletId, username, 0.0); // New users start with 0 balance
    if (role == UserRole::ADMIN_USER && username == "admin") { // Special case for initial admin
        newWallet.balance = 1000.0; // Give initial admin some points
    }


    storage.addUser(newUser);
    storage.addWallet(newWallet);

    if (!storage.saveUsers() || !storage.saveWallets()) {
        std::cerr << "Loi: Khong the luu du lieu nguoi dung hoac vi." << std::endl;
        // Potentially remove user and wallet if save fails to maintain consistency (complex)
        return false;
    }

    std::cout << "Dang ky tai khoan thanh cong cho: " << username << std::endl;
    if(autoGeneratedPassword && createdByAdmin) {
        std::cout << "Mat khau tu dong sinh la: " << password << " (Yeu cau nguoi dung doi mat khau sau khi dang nhap)" << std::endl;
    }
    return true;
}

bool AuthService::login(const std::string& username, const std::string& password) {
    UserAccount* user = storage.findUser(username);
    if (user == nullptr) {
        std::cerr << "Ten dang nhap khong ton tai." << std::endl;
        return false;
    }
    if (user->isLocked) {
        std::cerr << "Tai khoan da bi khoa do dang nhap sai qua nhieu lan." << std::endl;
        return false;
    }

    std::string hashedPasswordAttempt = Utils::mockHashPassword(password, user->salt);
    if (user->hashedPassword == hashedPasswordAttempt) {
        currentUser = user;
        currentUser->failedLoginAttempts = 0;
        currentUser->updatedAt = std::chrono::system_clock::now(); // Update last login time conceptually
        storage.saveUsers(); // Save changes like failedLoginAttempts reset
        std::cout << "Dang nhap thanh cong. Chao mung " << currentUser->fullName << "!" << std::endl;

        if (currentUser->isPasswordAutoGenerated) {
            std::cout << "Mat khau cua ban duoc tao tu dong. Ban PHAI thay doi mat khau ngay bay gio." << std::endl;
            // Directly call force change password or guide user
        }
        return true;
    } else {
        user->failedLoginAttempts++;
        std::cout << "Mat khau khong dung. Con lai " << MAX_FAILED_LOGIN_ATTEMPTS - user->failedLoginAttempts << " lan thu." << std::endl;
        if (user->failedLoginAttempts >= MAX_FAILED_LOGIN_ATTEMPTS) {
            user->isLocked = true;
            std::cout << "Tai khoan da bi khoa do dang nhap sai qua nhieu lan." << std::endl;
        }
        storage.saveUsers();
        return false;
    }
}

void AuthService::logout() {
    if (currentUser) {
        std::cout << "Dang xuat tai khoan: " << currentUser->username << std::endl;
        currentUser = nullptr;
    }
}

bool AuthService::isLoggedIn() const {
    return currentUser != nullptr;
}

UserAccount* AuthService::getCurrentUser() const {
    return currentUser;
}

bool AuthService::changePassword(UserAccount* user, const std::string& oldPassword, const std::string& newPassword) {
    if (!user) return false;
    std::string hashedOldPassword = Utils::mockHashPassword(oldPassword, user->salt);
    if (user->hashedPassword != hashedOldPassword) {
        std::cerr << "Mat khau cu khong dung." << std::endl;
        return false;
    }
    if (newPassword.length() < MIN_PASSWORD_LENGTH) {
        std::cerr << "Mat khau moi phai co it nhat " << MIN_PASSWORD_LENGTH << " ky tu." << std::endl;
        return false;
    }
    // user->salt = Utils::generateSalt(); // Optionally generate new salt
    user->hashedPassword = Utils::mockHashPassword(newPassword, user->salt);
    user->isPasswordAutoGenerated = false;
    user->updatedAt = std::chrono::system_clock::now();
    storage.saveUsers();
    std::cout << "Thay doi mat khau thanh cong." << std::endl;
    return true;
}
bool AuthService::forceChangePassword(UserAccount* user, const std::string& newPassword) {
    if (!user) return false;
     if (newPassword.length() < MIN_PASSWORD_LENGTH) {
        std::cerr << "Mat khau moi phai co it nhat " << MIN_PASSWORD_LENGTH << " ky tu." << std::endl;
        return false;
    }
    user->hashedPassword = Utils::mockHashPassword(newPassword, user->salt);
    user->isPasswordAutoGenerated = false;
    user->updatedAt = std::chrono::system_clock::now();
    storage.saveUsers();
    std::cout << "Mat khau da duoc cap nhat thanh cong." << std::endl;
    return true;
}


bool AuthService::setupOTP(UserAccount* user) {
    if (!user) return false;
    if (user->isOtpEnabled) {
        std::cout << "OTP da duoc kich hoat cho tai khoan nay." << std::endl;
        return false;
    }
    user->otpSecretKey = Utils::generateOTPSecret(); // Mock secret
    std::cout << "OTP da duoc kich hoat (MOCK). Ma bi mat cua ban la: " << user->otpSecretKey << std::endl;
    std::cout << "Trong ung dung thuc te, ban se quet ma QR hoac nhap ma nay vao ung dung Authenticator." << std::endl;
    std::cout << "Vi du ma OTP hien tai (MOCK): " << Utils::generateNumericOTP(user->otpSecretKey) << std::endl;

    std::string otpCode;
    std::cout << "Vui long nhap ma OTP tu ung dung cua ban de xac nhan: ";
    std::cin >> otpCode;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // consume newline

    if (Utils::validateOTP(user->otpSecretKey, otpCode)) { // Mock validation
        user->isOtpEnabled = true;
        user->updatedAt = std::chrono::system_clock::now();
        storage.saveUsers();
        std::cout << "Thiet lap OTP thanh cong." << std::endl;
        return true;
    } else {
        user->otpSecretKey = ""; // Clear if setup failed
        std::cerr << "Ma OTP khong hop le. Thiet lap OTP that bai." << std::endl;
        return false;
    }
}

bool AuthService::verifyOTP(UserAccount* user, const std::string& otpCode) {
    if (!user || !user->isOtpEnabled) {
        // std::cerr << "OTP chua duoc kich hoat hoac nguoi dung khong hop le." << std::endl;
        return false; // Or true if OTP is not enabled (depends on policy)
                      // For now, if OTP not enabled, verification is not needed.
    }
    if (Utils::validateOTP(user->otpSecretKey, otpCode)) { // Mock validation
        return true;
    }
    std::cerr << "Ma OTP khong hop le." << std::endl;
    return false;
}

bool AuthService::disableOTP(UserAccount* user, const std::string& passwordOrOtp) {
    if(!user || !user->isOtpEnabled) {
        std::cout << "OTP chua duoc kich hoat cho tai khoan nay." << std::endl;
        return false;
    }
    // For disabling, require current password AND OTP if possible, or just one
    // Simple check here: require OTP
    std::cout << "Nhap ma OTP hien tai de vo hieu hoa OTP: ";
    std::string otpCode;
    std::cin >> otpCode;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    if(verifyOTP(user, otpCode)) {
        user->isOtpEnabled = false;
        user->otpSecretKey = "";
        user->updatedAt = std::chrono::system_clock::now();
        storage.saveUsers();
        std::cout << "OTP da duoc vo hieu hoa." << std::endl;
        return true;
    } else {
        std::cerr << "Vo hieu hoa OTP that bai. Ma OTP khong dung." << std::endl;
        return false;
    }
}


bool AuthService::updateUserProfile(UserAccount* userToUpdate, const std::string& newFullName,
                                   const std::string& newEmail, const std::string& newPhone,
                                   UserAccount* adminRequesting) {
    if (!userToUpdate) return false;

    // Determine whose OTP is needed: the user being updated.
    UserAccount* otpOwner = userToUpdate;

    // If OTP is enabled for the user whose profile is being updated, require it
    if (otpOwner->isOtpEnabled) {
        std::cout << "Thao tac nay yeu cau xac thuc OTP." << std::endl;
        if (adminRequesting) {
            std::cout << "Quan tri vien (" << adminRequesting->username << ") dang yeu cau thay doi thong tin cho " << userToUpdate->username << "." << std::endl;
            std::cout << "Vui long yeu cau NGUOI DUNG " << userToUpdate->username << " cung cap ma OTP." << std::endl;
        } else {
            std::cout << "Vui long nhap ma OTP cua ban: ";
        }
        std::string otpCode;
        std::cin >> otpCode;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        if (!Utils::validateOTP(otpOwner->otpSecretKey, otpCode)) {
            std::cerr << "Xac thuc OTP that bai. Cap nhat thong tin khong thanh cong." << std::endl;
            return false;
        }
    } else {
        std::cout << "Luu y: OTP chua duoc kich hoat cho tai khoan nay. Can nhac kich hoat de tang bao mat." << std::endl;
    }

    // Proceed with updates
    bool changed = false;
    if (!newFullName.empty() && userToUpdate->fullName != newFullName) {
        userToUpdate->fullName = newFullName;
        changed = true;
    }
    if (!newEmail.empty() && userToUpdate->email != newEmail) {
        userToUpdate->email = newEmail;
        changed = true;
    }
    if (!newPhone.empty() && userToUpdate->phoneNumber != newPhone) {
        userToUpdate->phoneNumber = newPhone;
        changed = true;
    }

    if (changed) {
        userToUpdate->updatedAt = std::chrono::system_clock::now();
        if (storage.saveUsers()) {
            std::cout << "Cap nhat thong tin ca nhan thanh cong." << std::endl;
            return true;
        } else {
            std::cerr << "Loi khi luu thong tin cap nhat." << std::endl;
            // Consider reverting changes in memory if save fails (complex)
            return false;
        }
    } else {
        std::cout << "Khong co thong tin nao duoc thay doi." << std::endl;
        return true; // No changes made, but operation is "successful"
    }
}